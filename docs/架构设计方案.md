# Windows定时关机软件 - 技术架构设计方案

## 1. 项目概述

### 1.1 产品定位
轻量化Windows定时关机工具，专为普通家庭用户设计，核心功能是通过极简操作实现定时关机。

### 1.2 技术目标
- **性能**: 启动时间≤2秒，内存占用≤50MB，CPU占用≤5%
- **兼容性**: 支持Windows 10(1903+)和Windows 11
- **安装包**: 体积≤5MB
- **权限**: 仅需标准用户权限

## 2. 整体架构设计

### 2.1 架构模式
采用**分层架构**模式，分为以下层次：

```
┌─────────────────────────────────────┐
│           用户界面层 (UI Layer)        │
├─────────────────────────────────────┤
│         业务逻辑层 (Business Layer)    │
├─────────────────────────────────────┤
│         数据访问层 (Data Layer)        │
├─────────────────────────────────────┤
│         系统接口层 (System Layer)      │
└─────────────────────────────────────┘
```

### 2.2 核心模块划分

基于PRD中的6个Epic，设计对应的技术模块：

| Epic | 模块名称 | 技术实现 | 主要职责 |
|------|----------|----------|----------|
| EP01 | TimeParser | regex + chrono | 时间解析和校验 |
| EP02 | CountdownManager | tokio + mpsc | 倒计时管理和更新 |
| EP03 | ShutdownExecutor | winapi + std::process | 关机操作执行 |
| EP04 | TaskPersistence | serde + std::fs | 任务持久化存储 |
| EP05 | UIManager | egui + tray-icon | 界面交互和托盘 |
| EP06 | SystemCompat | winapi + version检测 | 系统兼容性 |

## 3. 技术选型

### 3.1 核心依赖

```toml
[dependencies]
# 异步运行时
tokio = { version = "1.0", features = ["full"] }

# GUI框架
egui = "0.24"
eframe = { version = "0.24", features = ["default_fonts", "glow"] }

# 系统托盘
tray-icon = "0.14"
winit = "0.29"

# 时间处理
chrono = { version = "0.4", features = ["serde"] }

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 正则表达式
regex = "1.10"

# Windows API
winapi = { version = "0.3", features = [
    "winuser", "processthreadsapi", "winbase", 
    "shellapi", "synchapi", "winnt"
] }

# 错误处理
thiserror = "1.0"
anyhow = "1.0"

# 日志
log = "0.4"
env_logger = "0.10"
```

### 3.2 架构决策理由

1. **异步运行时选择Tokio**：
   - 成熟稳定，生态丰富
   - 支持精确的定时器功能
   - 优秀的多线程调度性能

2. **GUI框架选择egui**：
   - 轻量级，编译后体积小
   - 纯Rust实现，无外部依赖
   - 支持现代UI设计

3. **数据存储选择JSON**：
   - 人类可读，便于调试
   - serde支持完善
   - 符合轻量化要求

## 4. 模块详细设计

### 4.1 TimeParser模块 (EP01)

**职责**: 解析用户输入的时间表达式

```rust
pub struct TimeParser {
    patterns: Vec<TimePattern>,
}

pub enum TimeInput {
    Duration(Duration),      // "30分钟"
    AbsoluteTime(DateTime),  // "今晚22:00"
    DailyTime(NaiveTime),   // 每日重复
}

impl TimeParser {
    pub fn parse(&self, input: &str) -> Result<TimeInput, ParseError>;
    pub fn validate(&self, input: &TimeInput) -> Result<(), ValidationError>;
}
```

**支持的时间格式**:
- 相对时间: "30分钟", "2小时", "1小时30分钟"
- 绝对时间: "今晚22:00", "明天10:00", "22:30"
- 每日时间: "22:00" (每日模式)

### 4.2 CountdownManager模块 (EP02)

**职责**: 管理倒计时状态和更新

```rust
pub struct CountdownManager {
    target_time: Option<DateTime<Local>>,
    task_type: TaskType,
    status: CountdownStatus,
    update_sender: mpsc::Sender<CountdownUpdate>,
}

pub enum CountdownStatus {
    Idle,
    Running { remaining: Duration },
    Finished,
    Cancelled,
}

impl CountdownManager {
    pub async fn start_countdown(&mut self, target: DateTime<Local>);
    pub fn cancel_countdown(&mut self);
    pub fn get_remaining_time(&self) -> Option<Duration>;
}
```

**关键特性**:
- 基于系统时间戳计算，避免累积误差
- 支持系统休眠/唤醒后的时间校准
- 通过mpsc通道与UI线程通信

### 4.3 ShutdownExecutor模块 (EP03)

**职责**: 执行系统关机操作

```rust
pub struct ShutdownExecutor {
    method: ShutdownMethod,
}

pub enum ShutdownMethod {
    Command,  // shutdown.exe
    WinAPI,   // InitiateSystemShutdownEx
}

impl ShutdownExecutor {
    pub async fn shutdown(&self, delay_seconds: u32) -> Result<(), ShutdownError>;
    pub fn cancel_shutdown(&self) -> Result<(), ShutdownError>;
    pub fn check_permissions(&self) -> bool;
}
```

**实现策略**:
- 优先使用`shutdown.exe /s /t <seconds>`命令（兼容性好）
- 备选使用Windows API `InitiateSystemShutdownEx`
- 支持关机失败检测和用户提示

### 4.4 TaskPersistence模块 (EP04)

**职责**: 任务数据的持久化存储

```rust
#[derive(Serialize, Deserialize)]
pub struct TaskData {
    pub task_type: TaskType,
    pub target_time: Option<DateTime<Local>>,
    pub daily_time: Option<NaiveTime>,
    pub enabled: bool,
    pub created_at: DateTime<Local>,
}

pub struct TaskPersistence {
    storage_path: PathBuf,
}

impl TaskPersistence {
    pub fn save_task(&self, task: &TaskData) -> Result<(), PersistenceError>;
    pub fn load_task(&self) -> Result<Option<TaskData>, PersistenceError>;
    pub fn clear_task(&self) -> Result<(), PersistenceError>;
}
```

**存储位置**: `%LOCALAPPDATA%\QtShut\tasks.json`

### 4.5 UIManager模块 (EP05)

**职责**: 用户界面和交互管理

```rust
pub struct UIManager {
    app_state: AppState,
    tray_icon: Option<TrayIcon>,
    countdown_receiver: mpsc::Receiver<CountdownUpdate>,
}

pub struct AppState {
    pub task_type: TaskType,
    pub time_input: String,
    pub countdown_status: CountdownStatus,
    pub error_message: Option<String>,
}

impl eframe::App for UIManager {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame);
}
```

**界面布局**:
- 顶部: 任务类型切换按钮
- 中部: 时间输入框和倒计时显示
- 底部: 开始/取消操作按钮
- 托盘: 最小化状态显示

### 4.6 SystemCompat模块 (EP06)

**职责**: 系统兼容性检测和适配

```rust
pub struct SystemCompat {
    os_version: WindowsVersion,
    permissions: UserPermissions,
}

pub struct WindowsVersion {
    pub major: u32,
    pub minor: u32,
    pub build: u32,
}

impl SystemCompat {
    pub fn check_compatibility() -> Result<Self, CompatError>;
    pub fn is_supported(&self) -> bool;
    pub fn get_shutdown_method(&self) -> ShutdownMethod;
}
```

## 5. 数据流设计

### 5.1 主要数据流

```
用户输入 → TimeParser → CountdownManager → ShutdownExecutor
    ↓              ↓              ↓
UIManager ← TaskPersistence ← SystemCompat
```

### 5.2 异步通信机制

```rust
// 倒计时更新通道
type CountdownChannel = mpsc::Receiver<CountdownUpdate>;

// UI事件通道
type UIEventChannel = mpsc::Sender<UIEvent>;

pub enum CountdownUpdate {
    Tick(Duration),
    Finished,
    Cancelled,
    Error(String),
}

pub enum UIEvent {
    StartCountdown(TimeInput),
    CancelCountdown,
    MinimizeToTray,
    RestoreFromTray,
}
```

## 6. 错误处理策略

### 6.1 错误类型定义

```rust
#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("时间解析错误: {0}")]
    ParseError(String),
    
    #[error("关机操作失败: {0}")]
    ShutdownError(String),
    
    #[error("文件操作错误: {0}")]
    PersistenceError(String),
    
    #[error("系统兼容性错误: {0}")]
    CompatibilityError(String),
}
```

### 6.2 错误处理原则

1. **用户友好**: 所有错误信息都转换为用户可理解的中文提示
2. **优雅降级**: 非关键功能失败不影响核心功能
3. **日志记录**: 详细错误信息记录到日志文件
4. **恢复机制**: 支持从错误状态自动恢复

## 7. 性能优化策略

### 7.1 启动优化
- 延迟加载非关键组件
- 异步初始化系统检测
- 缓存系统信息

### 7.2 运行时优化
- 使用高效的定时器实现
- 最小化UI刷新频率
- 智能的托盘更新策略

### 7.3 内存优化
- 避免不必要的字符串分配
- 使用引用而非克隆
- 及时释放大对象

## 8. 安全考虑

### 8.1 权限控制
- 仅使用标准用户权限
- 关机操作需用户确认
- 避免提权攻击

### 8.2 数据安全
- 本地数据不包含敏感信息
- 文件权限限制为当前用户
- 不进行网络通信

## 9. 测试策略

### 9.1 单元测试
- 时间解析逻辑测试
- 倒计时计算测试
- 数据持久化测试

### 9.2 集成测试
- 完整工作流测试
- 系统兼容性测试
- 错误场景测试

### 9.3 用户测试
- 易用性测试
- 性能基准测试
- 兼容性验证

## 10. 部署和发布

### 10.1 构建配置
```toml
[profile.release]
opt-level = "z"     # 优化体积
lto = true          # 链接时优化
codegen-units = 1   # 单个代码生成单元
panic = "abort"     # 减少二进制大小
strip = true        # 移除调试符号
```

### 10.2 发布流程
1. 自动化构建和测试
2. 多平台兼容性验证
3. 安装包制作和签名
4. 版本发布和更新

---

本架构设计确保了系统的可扩展性、可维护性和高性能，同时满足PRD中定义的所有功能和非功能性需求。